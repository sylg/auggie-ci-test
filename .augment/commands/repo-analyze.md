---
description: Analyze repository and generate CI config for failure analysis and auto-healing
argument-hint: [--output-dir path]
---

# Repository Analyzer (CI Healing Focus)

Analyze the current repository to understand its tech stack, testing patterns, CI layout, and safety boundaries. Output a configuration that enables robust CI failure analysis and safe auto-healing (including commit/PR automation).

## Objectives

- Prefer concrete evidence from repo files over assumptions.
- Capture CI context (workflows, jobs, services, env, required checks).
- Define safe auto-fix boundaries and verification commands.
- Enable consistent commit and PR generation.
- Output a stable, machine-readable config with confidence notes.

## Constraints

- Use local repository data only (no external network calls).
- If information is missing, set `null` and add a short note under `notes`.
- Do not run destructive operations or modify files during analysis.

## Analysis Steps

### 1. Detect Tech Stack

Examine the repository to identify:

**Package Manager & Runtime:**
- Check for `package.json` (npm/yarn/pnpm)
- Check for `requirements.txt` / `pyproject.toml` (Python)
- Check for `go.mod` (Go)
- Check for `Cargo.toml` (Rust)
- Detect Node/Python/Go/Rust versions from `.nvmrc`, `.tool-versions`, `.python-version`, `go.mod`, `rust-toolchain*`
- Detect monorepo/workspaces (`pnpm-workspace.yaml`, `lerna.json`, `turbo.json`, `nx.json`)

**Language & Framework:**
- TypeScript vs JavaScript (check `tsconfig.json`)
- React, Next.js, Vue, etc. (check dependencies)
- Express, Fastify, NestJS, etc. (check dependencies)

**Testing Framework:**
- Jest, Vitest, Mocha (JS/TS)
- pytest, unittest (Python)
- go test (Go)

**Linting & Formatting:**
- ESLint, Prettier, Biome
- pylint, ruff, black
- golangci-lint

**CI/CD:**
- GitHub Actions (`.github/workflows/`)
- GitLab CI (`.gitlab-ci.yml`)
- Other CI systems

### 2. Extract Commands and Scripts

Identify authoritative commands from repo config (do not guess):
- `package.json` scripts (including workspace packages if monorepo)
- `Makefile`, `tox.ini`, `noxfile.py`, `poetry` scripts
- `go test` targets, `cargo test` profiles
- Any CI workflow steps that override scripts

Capture:
- install command
- build, typecheck, lint, test, test:coverage
- single-test selector (e.g., `jest -t`, `vitest -t`, `pytest -k`, `go test ./pkg -run`)
- test environment setup (db migrations, fixtures)

### 3. Analyze Project Structure

Identify patterns:
- Where are tests located? (`__tests__/`, `*.test.ts`, `tests/`)
- Where is source code? (`src/`, `lib/`, `app/`)
- Are there E2E tests? (`e2e/`, `cypress/`, `playwright/`)
- Database/ORM used? (Prisma, TypeORM, Sequelize)
- Are there generated code or build artifacts to avoid touching?

### 4. Inspect CI Configuration

From CI config files, extract:
- Workflow names, job names, and primary steps
- Matrix builds (OS, Node/Python versions)
- Services (db, redis) and required env vars
- Caches and artifacts (paths, keys)
- Required checks (by job name if documented)
- Default branch (`main`/`master`) if specified

### 5. Identify Conventions and Guardrails

Look for:
- Commit message style (`commitlint`, `semantic-release`, `CONTRIBUTING`)
- Branch naming rules
- PR template (`.github/pull_request_template.md`)
- CODEOWNERS (for reviewers)
- Files/paths that should never be auto-edited (infra, migrations, workflows)

### 6. Identify Common Failure Patterns

Based on the tech stack, list likely failure types:

**TypeScript + Jest Project:**
```yaml
common_failures:
  - pattern: "TS2322: Type .* is not assignable"
    type: type_error
    risk: low
    auto_fix: true
  - pattern: "Cannot find module"
    type: import_error
    risk: low
    auto_fix: true
  - pattern: "Snapshot .* does not match"
    type: snapshot_mismatch
    risk: medium
    auto_fix: false
```

**Python + pytest Project:**
```yaml
common_failures:
  - pattern: "AssertionError"
    type: test_failure
    risk: medium
  - pattern: "ModuleNotFoundError"
    type: import_error
    risk: low
  - pattern: "TypeError: .* missing .* required"
    type: type_error
    risk: low
```

### 4. Output Configuration

Generate a YAML configuration file:

```yaml
# .augment/repo-config.yml
# Auto-generated by /repo-analyze

project:
  name: [detected from package.json or directory]
  type: [web-app|api|library|cli|monorepo]
  root: .
  monorepo: true|false

tech_stack:
  language: typescript
  version: "5.x"
  runtime: node
  runtime_version: "20"
  framework: next.js
  framework_version: "14.x"
  package_manager: npm|yarn|pnpm|pip|poetry|go|cargo

commands:
  install: npm ci
  build: npm run build
  typecheck: npm run typecheck
  lint: npm run lint
  test: npm test
  test_coverage: npm run test:coverage
  test_single: npm test -- [pattern]

structure:
  source: src/
  tests: src/**/__tests__/
  e2e: e2e/
  config: ./

ci:
  provider: github-actions
  workflows:
    - name: ci
      path: .github/workflows/ci.yml
      jobs: [lint, test, build]
  matrix:
    os: [ubuntu-latest]
    runtime: ["20"]
  services: [postgres, redis]
  required_checks: [lint, test, build]
  default_branch: main

failure_patterns:
  type_error:
    patterns:
      - "TS\\d+:"
      - "Type .* is not assignable"
    risk: low
    verification: npm run typecheck

  lint_error:
    patterns:
      - "ESLint:"
      - "Parsing error:"
    risk: low
    verification: npm run lint

  test_failure:
    patterns:
      - "FAIL src/"
      - "Expected .* Received"
    risk: medium
    verification: npm test

  build_error:
    patterns:
      - "Build failed"
      - "Module not found"
    risk: medium
    verification: npm run build

  dependency_issue:
    patterns:
      - "ERESOLVE"
      - "Could not resolve dependency"
    risk: high
    verification: null

verification:
  quick: npm run typecheck && npm run lint
  full: npm run typecheck && npm run lint && npm test && npm run build

safety:
  protected_paths:
    - .github/workflows/
    - infra/
    - migrations/
  max_patch_lines: 200
  avoid_file_globs:
    - "**/*.lock"
  risk_overrides:
    high: [dependency_issue, infrastructure, flaky_test]
    low: [lint_error, type_error, import_error]

conventions:
  commit_style: conventional  # or: none, angular, etc.
  branch_pattern: "feature/*|fix/*|chore/*"
  pr_template: .github/pull_request_template.md
  codeowners: .github/CODEOWNERS

automation:
  branch_prefix: "ci-heal/"
  commit_message_template: "fix(ci): <short summary>"
  pr_title_template: "CI heal: <short summary>"
  pr_body_template: |
    ## Root cause
    <one sentence>

    ## Fix
    <what changed and why>

    ## Verification
    <commands run or not run and why>
  labels: [ci, auto-fix]
  reviewers: []
  change_policy:
    minimal_diff: true
    allow_refactor: false
    update_snapshots: false
    update_lockfiles: "only-if-required"

notes:
  - "Set any unknown fields to null and add a brief note here."
evidence:
  runtime_version: ".nvmrc"
  test_command: "package.json scripts.test"
```

### 5. Generate Custom Commands (Optional)

If `--generate-commands` flag is passed, create customized command files:

- `.augment/commands/ci-heal.md` - Customized with repo-specific patterns
- `.augment/commands/ci-analyze.md` - Customized error detection

When customizing, include repo-specific commit/PR conventions and safety rules so the healer can generate a branch, commit, and PR with minimal review overhead.

## Usage

```bash
# Analyze repo and output config
auggie /repo-analyze

# Analyze and generate custom commands
auggie /repo-analyze --generate-commands

# Output to specific directory
auggie /repo-analyze --output-dir .augment/
```
